// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package types

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ChatCompletionToolType.
const (
	Function ChatCompletionToolType = "function"
)

// Defines values for FinishReason.
const (
	ContentFilter FinishReason = "content_filter"
	FunctionCall  FinishReason = "function_call"
	Length        FinishReason = "length"
	Stop          FinishReason = "stop"
	ToolCalls     FinishReason = "tool_calls"
)

// Defines values for ImageContentPartType.
const (
	ImageContentPartTypeImageURL ImageContentPartType = "image_url"
)

// Defines values for ImageURLDetail.
const (
	Auto ImageURLDetail = "auto"
	High ImageURLDetail = "high"
	Low  ImageURLDetail = "low"
)

// Defines values for MessageRole.
const (
	Assistant MessageRole = "assistant"
	System    MessageRole = "system"
	Tool      MessageRole = "tool"
	User      MessageRole = "user"
)

// Defines values for Provider.
const (
	Anthropic   Provider = "anthropic"
	Cloudflare  Provider = "cloudflare"
	Cohere      Provider = "cohere"
	Deepseek    Provider = "deepseek"
	Google      Provider = "google"
	Groq        Provider = "groq"
	Mistral     Provider = "mistral"
	Moonshot    Provider = "moonshot"
	Ollama      Provider = "ollama"
	OllamaCloud Provider = "ollama_cloud"
	Openai      Provider = "openai"
)

// Defines values for ProviderAuthType.
const (
	Bearer  ProviderAuthType = "bearer"
	None    ProviderAuthType = "none"
	Query   ProviderAuthType = "query"
	Xheader ProviderAuthType = "xheader"
)

// Defines values for SSEventEvent.
const (
	ContentDelta SSEventEvent = "content-delta"
	ContentEnd   SSEventEvent = "content-end"
	ContentStart SSEventEvent = "content-start"
	MessageEnd   SSEventEvent = "message-end"
	MessageStart SSEventEvent = "message-start"
	StreamEnd    SSEventEvent = "stream-end"
	StreamStart  SSEventEvent = "stream-start"
)

// Defines values for TextContentPartType.
const (
	Text TextContentPartType = "text"
)

// ChatCompletionChoice defines model for ChatCompletionChoice.
type ChatCompletionChoice struct {
	// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
	// `length` if the maximum number of tokens specified in the request was reached,
	// `content_filter` if content was omitted due to a flag from our content filters,
	// `tool_calls` if the model called a tool.
	FinishReason FinishReason `json:"finish_reason"`

	// Index The index of the choice in the list of choices.
	Index int `json:"index"`

	// Message Message structure for provider requests
	Message Message `json:"message"`
}

// ChatCompletionMessageToolCall defines model for ChatCompletionMessageToolCall.
type ChatCompletionMessageToolCall struct {
	// Function The function that the model called.
	Function ChatCompletionMessageToolCallFunction `json:"function"`

	// ID The ID of the tool call.
	ID string `json:"id"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionToolType `json:"type"`
}

// ChatCompletionMessageToolCallChunk defines model for ChatCompletionMessageToolCallChunk.
type ChatCompletionMessageToolCallChunk struct {
	// Function The function that the model called.
	Function *ChatCompletionMessageToolCallFunction `json:"function,omitempty"`

	// ID The ID of the tool call.
	ID    *string `json:"id,omitempty"`
	Index int     `json:"index"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type *string `json:"type,omitempty"`
}

// ChatCompletionMessageToolCallFunction The function that the model called.
type ChatCompletionMessageToolCallFunction struct {
	// Arguments The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
	Arguments string `json:"arguments"`

	// Name The name of the function to call.
	Name string `json:"name"`
}

// ChatCompletionStreamChoice defines model for ChatCompletionStreamChoice.
type ChatCompletionStreamChoice struct {
	// Delta A chat completion delta generated by streamed model responses.
	Delta ChatCompletionStreamResponseDelta `json:"delta"`

	// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
	// `length` if the maximum number of tokens specified in the request was reached,
	// `content_filter` if content was omitted due to a flag from our content filters,
	// `tool_calls` if the model called a tool.
	FinishReason FinishReason `json:"finish_reason"`

	// Index The index of the choice in the list of choices.
	Index int `json:"index"`

	// Logprobs Log probability information for the choice.
	Logprobs *struct {
		// Content A list of message content tokens with log probability information.
		Content []ChatCompletionTokenLogprob `json:"content"`

		// Refusal A list of message refusal tokens with log probability information.
		Refusal []ChatCompletionTokenLogprob `json:"refusal"`
	} `json:"logprobs,omitempty"`
}

// ChatCompletionStreamOptions Options for streaming response. Only set this when you set `stream: true`.
type ChatCompletionStreamOptions struct {
	// IncludeUsage If set, an additional chunk will be streamed before the `data: [DONE]` message. The `usage` field on this chunk shows the token usage statistics for the entire request, and the `choices` field will always be an empty array. All other chunks will also include a `usage` field, but with a null value.
	IncludeUsage bool `json:"include_usage"`
}

// ChatCompletionStreamResponseDelta A chat completion delta generated by streamed model responses.
type ChatCompletionStreamResponseDelta struct {
	// Content The contents of the chunk message.
	Content string `json:"content"`

	// Reasoning The reasoning of the chunk message. Same as reasoning_content.
	Reasoning *string `json:"reasoning,omitempty"`

	// ReasoningContent The reasoning content of the chunk message.
	ReasoningContent *string `json:"reasoning_content,omitempty"`

	// Refusal The refusal message generated by the model.
	Refusal *string `json:"refusal,omitempty"`

	// Role Role of the message sender
	Role      MessageRole                           `json:"role"`
	ToolCalls *[]ChatCompletionMessageToolCallChunk `json:"tool_calls,omitempty"`
}

// ChatCompletionTokenLogprob defines model for ChatCompletionTokenLogprob.
type ChatCompletionTokenLogprob struct {
	// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
	Bytes []int `json:"bytes"`

	// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
	Logprob float32 `json:"logprob"`

	// Token The token.
	Token string `json:"token"`

	// TopLogprobs List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
	TopLogprobs []struct {
		// Bytes A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
		Bytes []int `json:"bytes"`

		// Logprob The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
		Logprob float32 `json:"logprob"`

		// Token The token.
		Token string `json:"token"`
	} `json:"top_logprobs"`
}

// ChatCompletionTool defines model for ChatCompletionTool.
type ChatCompletionTool struct {
	Function FunctionObject `json:"function"`

	// Type The type of the tool. Currently, only `function` is supported.
	Type ChatCompletionToolType `json:"type"`
}

// ChatCompletionToolType The type of the tool. Currently, only `function` is supported.
type ChatCompletionToolType string

// CompletionUsage Usage statistics for the completion request.
type CompletionUsage struct {
	// CompletionTokens Number of tokens in the generated completion.
	CompletionTokens int64 `json:"completion_tokens"`

	// PromptTokens Number of tokens in the prompt.
	PromptTokens int64 `json:"prompt_tokens"`

	// TotalTokens Total number of tokens used in the request (prompt + completion).
	TotalTokens int64 `json:"total_tokens"`
}

// Config defines model for Config.
type Config = any

// ContentPart A content part within a multimodal message
type ContentPart struct {
	union json.RawMessage
}

// CreateChatCompletionRequest defines model for CreateChatCompletionRequest.
type CreateChatCompletionRequest struct {
	// MaxTokens An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens.
	MaxTokens *int `json:"max_tokens,omitempty"`

	// Messages A list of messages comprising the conversation so far.
	Messages []Message `json:"messages"`

	// Model Model ID to use
	Model string `json:"model"`

	// ReasoningFormat The format of the reasoning content. Can be `raw` or `parsed`.
	// When specified as raw some reasoning models will output <think /> tags. When specified as parsed the model will output the reasoning under  `reasoning` or `reasoning_content` attribute.
	ReasoningFormat *string `json:"reasoning_format,omitempty"`

	// Stream If set to true, the model response data will be streamed to the client as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).
	Stream *bool `json:"stream,omitempty"`

	// StreamOptions Options for streaming response. Only set this when you set `stream: true`.
	StreamOptions *ChatCompletionStreamOptions `json:"stream_options,omitempty"`

	// Tools A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.
	Tools *[]ChatCompletionTool `json:"tools,omitempty"`
}

// CreateChatCompletionResponse Represents a chat completion response returned by model, based on the provided input.
type CreateChatCompletionResponse struct {
	// Choices A list of chat completion choices. Can be more than one if `n` is greater than 1.
	Choices []ChatCompletionChoice `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the chat completion was created.
	Created int `json:"created"`

	// ID A unique identifier for the chat completion.
	ID string `json:"id"`

	// Model The model used for the chat completion.
	Model string `json:"model"`

	// Object The object type, which is always `chat.completion`.
	Object string `json:"object"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// CreateChatCompletionStreamResponse Represents a streamed chunk of a chat completion response returned
// by the model, based on the provided input.
type CreateChatCompletionStreamResponse struct {
	// Choices A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the
	// last chunk if you set `stream_options: {"include_usage": true}`.
	Choices []ChatCompletionStreamChoice `json:"choices"`

	// Created The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
	Created int `json:"created"`

	// ID A unique identifier for the chat completion. Each chunk has the same ID.
	ID string `json:"id"`

	// Model The model to generate the completion.
	Model string `json:"model"`

	// Object The object type, which is always `chat.completion.chunk`.
	Object string `json:"object"`

	// ReasoningFormat The format of the reasoning content. Can be `raw` or `parsed`.
	// When specified as raw some reasoning models will output <think /> tags. When specified as parsed the model will output the reasoning under reasoning_content.
	ReasoningFormat *string `json:"reasoning_format,omitempty"`

	// SystemFingerprint This fingerprint represents the backend configuration that the model runs with.
	// Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
	SystemFingerprint *string `json:"system_fingerprint,omitempty"`

	// Usage Usage statistics for the completion request.
	Usage *CompletionUsage `json:"usage,omitempty"`
}

// Endpoints defines model for Endpoints.
type Endpoints struct {
	Chat   string `json:"chat"`
	Models string `json:"models"`
}

// Error defines model for Error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// FinishReason The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
// `length` if the maximum number of tokens specified in the request was reached,
// `content_filter` if content was omitted due to a flag from our content filters,
// `tool_calls` if the model called a tool.
type FinishReason string

// FunctionObject defines model for FunctionObject.
type FunctionObject struct {
	// Description A description of what the function does, used by the model to choose when and how to call the function.
	Description *string `json:"description,omitempty"`

	// Name The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
	Name string `json:"name"`

	// Parameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
	// Omitting `parameters` defines a function with an empty parameter list.
	Parameters *FunctionParameters `json:"parameters,omitempty"`

	// Strict Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling).
	Strict *bool `json:"strict,omitempty"`
}

// FunctionParameters The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
// Omitting `parameters` defines a function with an empty parameter list.
type FunctionParameters map[string]any

// ImageContentPart Image content part
type ImageContentPart struct {
	// ImageURL Image URL configuration
	ImageURL ImageURL `json:"image_url"`

	// Type Content type identifier
	Type ImageContentPartType `json:"type"`
}

// ImageContentPartType Content type identifier
type ImageContentPartType string

// ImageURL Image URL configuration
type ImageURL struct {
	// Detail Image detail level for vision processing
	Detail *ImageURLDetail `json:"detail,omitempty"`

	// URL URL of the image (data URLs supported)
	URL string `json:"url"`
}

// ImageURLDetail Image detail level for vision processing
type ImageURLDetail string

// ListModelsResponse Response structure for listing models
type ListModelsResponse struct {
	Data     []Model   `json:"data"`
	Object   string    `json:"object"`
	Provider *Provider `json:"provider,omitempty"`
}

// ListToolsResponse Response structure for listing MCP tools
type ListToolsResponse struct {
	// Data Array of available MCP tools
	Data []MCPTool `json:"data"`

	// Object Always "list"
	Object string `json:"object"`
}

// MCPTool An MCP tool definition
type MCPTool struct {
	// Description A description of what the tool does
	Description string `json:"description"`

	// InputSchema JSON schema for the tool's input parameters
	InputSchema *map[string]any `json:"input_schema,omitempty"`

	// Name The name of the tool
	Name string `json:"name"`

	// Server The MCP server that provides this tool
	Server string `json:"server"`
}

// Message Message structure for provider requests
type Message struct {
	// Content Message content - either text or multimodal content parts
	Content MessageContent `json:"content"`

	// Reasoning The reasoning of the chunk message. Same as reasoning_content.
	Reasoning *string `json:"reasoning,omitempty"`

	// ReasoningContent The reasoning content of the chunk message.
	ReasoningContent *string `json:"reasoning_content,omitempty"`

	// Role Role of the message sender
	Role       MessageRole                      `json:"role"`
	ToolCallID *string                          `json:"tool_call_id,omitempty"`
	ToolCalls  *[]ChatCompletionMessageToolCall `json:"tool_calls,omitempty"`
}

// MessageContent Message content - either text or multimodal content parts
type MessageContent struct {
	union json.RawMessage
}

// MessageContent0 Text content (backward compatibility)
type MessageContent0 = string

// MessageContent1 Array of content parts for multimodal messages
type MessageContent1 = []ContentPart

// MessageRole Role of the message sender
type MessageRole string

// Model Common model information
type Model struct {
	Created  int64    `json:"created"`
	ID       string   `json:"id"`
	Object   string   `json:"object"`
	OwnedBy  string   `json:"owned_by"`
	ServedBy Provider `json:"served_by"`
}

// Provider defines model for Provider.
type Provider string

// ProviderAuthType Authentication type for providers
type ProviderAuthType string

// ProviderSpecificResponse Provider-specific response format. Examples:
//
// OpenAI GET /v1/models?provider=openai response:
// ```json
//
//	{
//	  "provider": "openai",
//	  "object": "list",
//	  "data": [
//	    {
//	      "id": "gpt-4",
//	      "object": "model",
//	      "created": 1687882410,
//	      "owned_by": "openai",
//	      "served_by": "openai"
//	    }
//	  ]
//	}
//
// ```
//
// Anthropic GET /v1/models?provider=anthropic response:
// ```json
//
//	{
//	  "provider": "anthropic",
//	  "object": "list",
//	  "data": [
//	    {
//	      "id": "gpt-4",
//	      "object": "model",
//	      "created": 1687882410,
//	      "owned_by": "openai",
//	      "served_by": "openai"
//	    }
//	  ]
//	}
//
// ```
type ProviderSpecificResponse = map[string]any

// SSEvent defines model for SSEvent.
type SSEvent struct {
	Data  *[]byte       `json:"data,omitempty"`
	Event *SSEventEvent `json:"event,omitempty"`
	Retry *int          `json:"retry,omitempty"`
}

// SSEventEvent defines model for SSEvent.Event.
type SSEventEvent string

// TextContentPart Text content part
type TextContentPart struct {
	// Text The text content
	Text string `json:"text"`

	// Type Content type identifier
	Type TextContentPartType `json:"type"`
}

// TextContentPartType Content type identifier
type TextContentPartType string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// InternalError defines model for InternalError.
type InternalError = Error

// MCPNotExposed defines model for MCPNotExposed.
type MCPNotExposed = Error

// ProviderResponse Provider-specific response format. Examples:
//
// OpenAI GET /v1/models?provider=openai response:
// ```json
//
//	{
//	  "provider": "openai",
//	  "object": "list",
//	  "data": [
//	    {
//	      "id": "gpt-4",
//	      "object": "model",
//	      "created": 1687882410,
//	      "owned_by": "openai",
//	      "served_by": "openai"
//	    }
//	  ]
//	}
//
// ```
//
// Anthropic GET /v1/models?provider=anthropic response:
// ```json
//
//	{
//	  "provider": "anthropic",
//	  "object": "list",
//	  "data": [
//	    {
//	      "id": "gpt-4",
//	      "object": "model",
//	      "created": 1687882410,
//	      "owned_by": "openai",
//	      "served_by": "openai"
//	    }
//	  ]
//	}
//
// ```
type ProviderResponse = ProviderSpecificResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ProviderRequest defines model for ProviderRequest.
type ProviderRequest struct {
	Messages *[]struct {
		Content *string `json:"content,omitempty"`
		Role    *string `json:"role,omitempty"`
	} `json:"messages,omitempty"`
	Model       *string  `json:"model,omitempty"`
	Temperature *float32 `json:"temperature,omitempty"`
}

// CreateChatCompletionParams defines parameters for CreateChatCompletion.
type CreateChatCompletionParams struct {
	// Provider Specific provider to use (default determined by model)
	Provider *Provider `form:"provider,omitempty" json:"provider,omitempty"`
}

// ListModelsParams defines parameters for ListModels.
type ListModelsParams struct {
	// Provider Specific provider to query (optional)
	Provider *Provider `form:"provider,omitempty" json:"provider,omitempty"`
}

// ProxyPatchJSONBody defines parameters for ProxyPatch.
type ProxyPatchJSONBody struct {
	Messages *[]struct {
		Content *string `json:"content,omitempty"`
		Role    *string `json:"role,omitempty"`
	} `json:"messages,omitempty"`
	Model       *string  `json:"model,omitempty"`
	Temperature *float32 `json:"temperature,omitempty"`
}

// ProxyPostJSONBody defines parameters for ProxyPost.
type ProxyPostJSONBody struct {
	Messages *[]struct {
		Content *string `json:"content,omitempty"`
		Role    *string `json:"role,omitempty"`
	} `json:"messages,omitempty"`
	Model       *string  `json:"model,omitempty"`
	Temperature *float32 `json:"temperature,omitempty"`
}

// ProxyPutJSONBody defines parameters for ProxyPut.
type ProxyPutJSONBody struct {
	Messages *[]struct {
		Content *string `json:"content,omitempty"`
		Role    *string `json:"role,omitempty"`
	} `json:"messages,omitempty"`
	Model       *string  `json:"model,omitempty"`
	Temperature *float32 `json:"temperature,omitempty"`
}

// CreateChatCompletionJSONRequestBody defines body for CreateChatCompletion for application/json ContentType.
type CreateChatCompletionJSONRequestBody = CreateChatCompletionRequest

// ProxyPatchJSONRequestBody defines body for ProxyPatch for application/json ContentType.
type ProxyPatchJSONRequestBody ProxyPatchJSONBody

// ProxyPostJSONRequestBody defines body for ProxyPost for application/json ContentType.
type ProxyPostJSONRequestBody ProxyPostJSONBody

// ProxyPutJSONRequestBody defines body for ProxyPut for application/json ContentType.
type ProxyPutJSONRequestBody ProxyPutJSONBody

// AsTextContentPart returns the union data inside the ContentPart as a TextContentPart
func (t ContentPart) AsTextContentPart() (TextContentPart, error) {
	var body TextContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextContentPart overwrites any union data inside the ContentPart as the provided TextContentPart
func (t *ContentPart) FromTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextContentPart performs a merge with any union data inside the ContentPart, using the provided TextContentPart
func (t *ContentPart) MergeTextContentPart(v TextContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageContentPart returns the union data inside the ContentPart as a ImageContentPart
func (t ContentPart) AsImageContentPart() (ImageContentPart, error) {
	var body ImageContentPart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageContentPart overwrites any union data inside the ContentPart as the provided ImageContentPart
func (t *ContentPart) FromImageContentPart(v ImageContentPart) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageContentPart performs a merge with any union data inside the ContentPart, using the provided ImageContentPart
func (t *ContentPart) MergeImageContentPart(v ImageContentPart) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContentPart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContentPart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMessageContent0 returns the union data inside the MessageContent as a MessageContent0
func (t MessageContent) AsMessageContent0() (MessageContent0, error) {
	var body MessageContent0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContent0 overwrites any union data inside the MessageContent as the provided MessageContent0
func (t *MessageContent) FromMessageContent0(v MessageContent0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContent0 performs a merge with any union data inside the MessageContent, using the provided MessageContent0
func (t *MessageContent) MergeMessageContent0(v MessageContent0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMessageContent1 returns the union data inside the MessageContent as a MessageContent1
func (t MessageContent) AsMessageContent1() (MessageContent1, error) {
	var body MessageContent1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMessageContent1 overwrites any union data inside the MessageContent as the provided MessageContent1
func (t *MessageContent) FromMessageContent1(v MessageContent1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMessageContent1 performs a merge with any union data inside the MessageContent, using the provided MessageContent1
func (t *MessageContent) MergeMessageContent1(v MessageContent1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MessageContent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MessageContent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
