---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mcp-filesystem-storage
  namespace: inference-gateway
  labels:
    app.kubernetes.io/name: mcp-filesystem-server
    app.kubernetes.io/part-of: inference-gateway-mcp
    app.kubernetes.io/component: mcp-server
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mcp-filesystem-server
  namespace: inference-gateway
  labels:
    app.kubernetes.io/name: mcp-filesystem-server
    app.kubernetes.io/part-of: inference-gateway-mcp
    app.kubernetes.io/component: mcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: mcp-filesystem-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: mcp-filesystem-server
        app.kubernetes.io/part-of: inference-gateway-mcp
        app.kubernetes.io/component: mcp-server
    spec:
      volumes:
        - name: app-workdir
          emptyDir: {}
        - name: config-src
          configMap:
            name: mcp-filesystem-server-config
        - name: filesystem-storage
          persistentVolumeClaim:
            claimName: mcp-filesystem-storage
      containers:
        - name: mcp-filesystem-server
          image: golang:1.23-alpine
          workingDir: /app
          securityContext:
            readOnlyRootFilesystem: false
          command:
            - sh
            - -c
            - |
              echo 'Setting up application files...' &&
              cp -rL /config/* /app &&
              go mod download &&
              go run main.go
          ports:
            - containerPort: 8083
              name: http
          volumeMounts:
            - name: filesystem-storage
              mountPath: /tmp/mcp-files
            - name: config-src
              mountPath: /config
              readOnly: true
            - name: app-workdir
              mountPath: /app
              readOnly: false
          livenessProbe:
            httpGet:
              path: /health
              port: 8083
            initialDelaySeconds: 120
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: 8083
            initialDelaySeconds: 50
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          resources:
            requests:
              memory: "128Mi"
              cpu: "50m"
            limits:
              memory: "1Gi"
              cpu: "500m"

---
apiVersion: v1
kind: Service
metadata:
  name: mcp-filesystem-server
  namespace: inference-gateway
  labels:
    app.kubernetes.io/name: mcp-filesystem-server
    app.kubernetes.io/part-of: inference-gateway-mcp
    app.kubernetes.io/component: mcp-server
spec:
  selector:
    app.kubernetes.io/name: mcp-filesystem-server
  ports:
    - port: 8083
      targetPort: 8083
      name: http

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-filesystem-server-config
  namespace: inference-gateway
  labels:
    app.kubernetes.io/name: mcp-filesystem-server
    app.kubernetes.io/part-of: inference-gateway-mcp
    app.kubernetes.io/component: mcp-server
data:
  main.go: |
    package main

    import (
      "context"
      "fmt"
      "io/fs"
      "log"
      "os"
      "path/filepath"
      "strings"

      "github.com/gin-gonic/gin"
      mcp_golang "github.com/metoro-io/mcp-golang"
      "github.com/metoro-io/mcp-golang/transport/http"
    )

    // FileWriteArgs defines the arguments for writing to a file
    type FileWriteArgs struct {
      Path    string `json:"path" jsonschema:"description=The file path to write to"`
      Content string `json:"content" jsonschema:"description=The content to write to the file"`
      Mode    string `json:"mode,omitempty" jsonschema:"description=Write mode: 'overwrite' (default) or 'append'"`
    }

    // FileReadArgs defines the arguments for reading from a file
    type FileReadArgs struct {
      Path string `json:"path" jsonschema:"description=The file path to read from"`
    }

    // FileDeleteArgs defines the arguments for deleting a file
    type FileDeleteArgs struct {
      Path string `json:"path" jsonschema:"description=The file path to delete"`
    }

    // DirectoryListArgs defines the arguments for listing directory contents
    type DirectoryListArgs struct {
      Path      string `json:"path" jsonschema:"description=The directory path to list"`
      Recursive bool   `json:"recursive,omitempty" jsonschema:"description=Whether to list recursively (default: false)"`
    }

    // DirectoryCreateArgs defines the arguments for creating a directory
    type DirectoryCreateArgs struct {
      Path string `json:"path" jsonschema:"description=The directory path to create"`
    }

    // FileExistsArgs defines the arguments for checking if a file exists
    type FileExistsArgs struct {
      Path string `json:"path" jsonschema:"description=The file path to check"`
    }

    // FileInfoArgs defines the arguments for getting file information
    type FileInfoArgs struct {
      Path string `json:"path" jsonschema:"description=The file path to get info for"`
    }

    const (
      // Base directory for file operations - in a real deployment this should be configurable
      BASE_DIR = "/tmp/mcp-files"
    )

    func main() {
      // Ensure base directory exists
      if err := os.MkdirAll(BASE_DIR, 0755); err != nil {
        log.Fatalf("Failed to create base directory: %v", err)
      }

      // Create a Gin transport
      transport := http.NewGinTransport()

      // Create a new server with the transport
      server := mcp_golang.NewServer(transport, mcp_golang.WithName("mcp-filesystem-server"), mcp_golang.WithVersion("0.0.1"))

      // Register write_file tool
      err := server.RegisterTool("write_file", "Write content to a file", func(ctx context.Context, args FileWriteArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("write_file request from User-Agent: %s", userAgent)

        log.Printf("Writing to file: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Create directory if it doesn't exist
        dir := filepath.Dir(fullPath)
        if err := os.MkdirAll(dir, 0755); err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to create directory: %v", err))), nil
        }

        // Determine write mode
        flags := os.O_CREATE | os.O_WRONLY
        switch args.Mode {
        case "append":
          flags |= os.O_APPEND
        default: // "overwrite" or empty
          flags |= os.O_TRUNC
        }

        // Write file
        file, err := os.OpenFile(fullPath, flags, 0644)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to open file: %v", err))), nil
        }
        defer file.Close()

        if _, err := file.WriteString(args.Content); err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to write content: %v", err))), nil
        }

        responseText := fmt.Sprintf("Successfully wrote %d bytes to %s", len(args.Content), args.Path)
        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
      })
      if err != nil {
        panic(err)
      }

      // Register read_file tool
      err = server.RegisterTool("read_file", "Read content from a file", func(ctx context.Context, args FileReadArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("read_file request from User-Agent: %s", userAgent)

        log.Printf("Reading from file: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Read file
        content, err := os.ReadFile(fullPath)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to read file: %v", err))), nil
        }

        responseText := fmt.Sprintf("File content from %s:\n\n%s", args.Path, string(content))
        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
      })
      if err != nil {
        panic(err)
      }

      // Register delete_file tool
      err = server.RegisterTool("delete_file", "Delete a file", func(ctx context.Context, args FileDeleteArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("delete_file request from User-Agent: %s", userAgent)

        log.Printf("Deleting file: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Delete file
        if err := os.Remove(fullPath); err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to delete file: %v", err))), nil
        }

        responseText := fmt.Sprintf("Successfully deleted file: %s", args.Path)
        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
      })
      if err != nil {
        panic(err)
      }

      // Register list_directory tool
      err = server.RegisterTool("list_directory", "List the contents of a directory", func(ctx context.Context, args DirectoryListArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("list_directory request from User-Agent: %s", userAgent)

        log.Printf("Listing directory: %s (recursive: %t)", args.Path, args.Recursive)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        var result strings.Builder
        result.WriteString(fmt.Sprintf("Contents of directory %s:\n\n", args.Path))

        if args.Recursive {
          err = filepath.WalkDir(fullPath, func(path string, d fs.DirEntry, err error) error {
            if err != nil {
              return err
            }
            // Get relative path from base
            relPath, err := filepath.Rel(fullPath, path)
            if err != nil {
              return err
            }
            if relPath == "." {
              return nil // Skip the root directory itself
            }

            info, err := d.Info()
            if err != nil {
              result.WriteString(fmt.Sprintf("  %s (error getting info: %v)\n", relPath, err))
              return nil
            }

            if d.IsDir() {
              result.WriteString(fmt.Sprintf("  üìÅ %s/\n", relPath))
            } else {
              result.WriteString(fmt.Sprintf("  üìÑ %s (%d bytes)\n", relPath, info.Size()))
            }
            return nil
          })
        } else {
          entries, err := os.ReadDir(fullPath)
          if err != nil {
            return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to read directory: %v", err))), nil
          }

          for _, entry := range entries {
            info, err := entry.Info()
            if err != nil {
              result.WriteString(fmt.Sprintf("  %s (error getting info: %v)\n", entry.Name(), err))
              continue
            }

            if entry.IsDir() {
              result.WriteString(fmt.Sprintf("  üìÅ %s/\n", entry.Name()))
            } else {
              result.WriteString(fmt.Sprintf("  üìÑ %s (%d bytes)\n", entry.Name(), info.Size()))
            }
          }
        }

        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error listing directory: %v", err))), nil
        }

        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(result.String())), nil
      })
      if err != nil {
        panic(err)
      }

      // Register create_directory tool
      err = server.RegisterTool("create_directory", "Create a directory", func(ctx context.Context, args DirectoryCreateArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("create_directory request from User-Agent: %s", userAgent)

        log.Printf("Creating directory: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Create directory
        if err := os.MkdirAll(fullPath, 0755); err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to create directory: %v", err))), nil
        }

        responseText := fmt.Sprintf("Successfully created directory: %s", args.Path)
        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
      })
      if err != nil {
        panic(err)
      }

      // Register file_exists tool
      err = server.RegisterTool("file_exists", "Check if a file or directory exists", func(ctx context.Context, args FileExistsArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("file_exists request from User-Agent: %s", userAgent)

        log.Printf("Checking if file exists: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Check if file exists
        info, err := os.Stat(fullPath)
        if os.IsNotExist(err) {
          responseText := fmt.Sprintf("File or directory does not exist: %s", args.Path)
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
        } else if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error checking file: %v", err))), nil
        }

        var responseText string
        if info.IsDir() {
          responseText = fmt.Sprintf("Directory exists: %s", args.Path)
        } else {
          responseText = fmt.Sprintf("File exists: %s", args.Path)
        }

        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(responseText)), nil
      })
      if err != nil {
        panic(err)
      }

      // Register file_info tool
      err = server.RegisterTool("file_info", "Get detailed information about a file or directory", func(ctx context.Context, args FileInfoArgs) (*mcp_golang.ToolResponse, error) {
        ginCtx, ok := ctx.Value("ginContext").(*gin.Context)
        if !ok {
          return nil, fmt.Errorf("ginContext not found in context")
        }
        userAgent := ginCtx.GetHeader("User-Agent")
        log.Printf("file_info request from User-Agent: %s", userAgent)

        log.Printf("Getting info for: %s", args.Path)

        // Validate and sanitize path
        fullPath, err := validatePath(args.Path)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Error: %v", err))), nil
        }

        // Get file info
        info, err := os.Stat(fullPath)
        if err != nil {
          return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(fmt.Sprintf("Failed to get file info: %v", err))), nil
        }

        var result strings.Builder
        result.WriteString(fmt.Sprintf("File information for %s:\n\n", args.Path))
        result.WriteString(fmt.Sprintf("  Name: %s\n", info.Name()))
        result.WriteString(fmt.Sprintf("  Size: %d bytes\n", info.Size()))
        result.WriteString(fmt.Sprintf("  Mode: %s\n", info.Mode()))
        result.WriteString(fmt.Sprintf("  Modified: %s\n", info.ModTime().Format("2006-01-02 15:04:05")))
        if info.IsDir() {
          result.WriteString("  Type: Directory\n")
        } else {
          result.WriteString("  Type: Regular file\n")
        }

        return mcp_golang.NewToolResponse(mcp_golang.NewTextContent(result.String())), nil
      })
      if err != nil {
        panic(err)
      }

      go server.Serve()

      // Create a Gin router
      r := gin.Default()

      // Add the MCP endpoint
      r.POST("/mcp", transport.Handler())

      // Add a health check endpoint
      r.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{
          "status": "ok",
        })
      })

      // Start the server
      log.Println("Starting Filesystem MCP server on 0.0.0.0:8083...")
      if err := r.Run("0.0.0.0:8083"); err != nil {
        log.Fatalf("Server error: %v", err)
      }
    }

    // validatePath validates and sanitizes the file path to prevent directory traversal attacks
    func validatePath(path string) (string, error) {
      // Clean the path to remove any relative components
      cleanPath := filepath.Clean(path)

      // Convert to absolute path within BASE_DIR
      fullPath := filepath.Join(BASE_DIR, cleanPath)

      // Ensure the path is within BASE_DIR
      if !strings.HasPrefix(fullPath, BASE_DIR) {
        return "", fmt.Errorf("path is outside allowed directory")
      }

      return fullPath, nil
    }

  go.mod: |
    module github.com/inference-gateway/inference-gateway/examples/kubernetes/mcp/mcp-servers/mcp-filesystem-server

    go 1.23.8

    require (
      github.com/gin-gonic/gin v1.10.1
      github.com/metoro-io/mcp-golang v0.13.0
    )

    require (
      github.com/bahlo/generic-list-go v0.2.0 // indirect
      github.com/buger/jsonparser v1.1.1 // indirect
      github.com/bytedance/sonic v1.11.6 // indirect
      github.com/bytedance/sonic/loader v0.1.1 // indirect
      github.com/cloudwego/base64x v0.1.4 // indirect
      github.com/cloudwego/iasm v0.2.0 // indirect
      github.com/gabriel-vasile/mimetype v1.4.3 // indirect
      github.com/gin-contrib/sse v0.1.0 // indirect
      github.com/go-playground/locales v0.14.1 // indirect
      github.com/go-playground/universal-translator v0.18.1 // indirect
      github.com/go-playground/validator/v10 v10.20.0 // indirect
      github.com/goccy/go-json v0.10.2 // indirect
      github.com/invopop/jsonschema v0.12.0 // indirect
      github.com/json-iterator/go v1.1.12 // indirect
      github.com/klauspost/cpuid/v2 v2.2.7 // indirect
      github.com/leodido/go-urn v1.4.0 // indirect
      github.com/mailru/easyjson v0.7.7 // indirect
      github.com/mattn/go-isatty v0.0.20 // indirect
      github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
      github.com/modern-go/reflect2 v1.0.2 // indirect
      github.com/pelletier/go-toml/v2 v2.2.2 // indirect
      github.com/pkg/errors v0.9.1 // indirect
      github.com/tidwall/gjson v1.18.0 // indirect
      github.com/tidwall/match v1.1.1 // indirect
      github.com/tidwall/pretty v1.2.1 // indirect
      github.com/tidwall/sjson v1.2.5 // indirect
      github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
      github.com/ugorji/go/codec v1.2.12 // indirect
      github.com/wk8/go-ordered-map/v2 v2.1.8 // indirect
      golang.org/x/arch v0.8.0 // indirect
      golang.org/x/crypto v0.23.0 // indirect
      golang.org/x/net v0.25.0 // indirect
      golang.org/x/sys v0.20.0 // indirect
      golang.org/x/text v0.15.0 // indirect
      google.golang.org/protobuf v1.34.1 // indirect
      gopkg.in/yaml.v3 v3.0.1 // indirect
    )

  go.sum: |
    github.com/bahlo/generic-list-go v0.2.0 h1:5sz/EEAK+ls5wF+NeqDpk5+iNdMDXrh3z3nPnH1Wvgk=
    github.com/bahlo/generic-list-go v0.2.0/go.mod h1:2KvAjgMlE5NNynlg/5iLrrCCZ2+5xWbdbCW3pNTGyYg=
    github.com/buger/jsonparser v1.1.1 h1:2PnMjfWD7wBILjqQbt530v576A/cAbQvEW9gGIpYMUs=
    github.com/buger/jsonparser v1.1.1/go.mod h1:6RYKKt7H4d4+iWqouImQ9R2FZql3VbhNgx27UK13J/0=
    github.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=
    github.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=
    github.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=
    github.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=
    github.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=
    github.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=
    github.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=
    github.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=
    github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
    github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
    github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
    github.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=
    github.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=
    github.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=
    github.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=
    github.com/gin-gonic/gin v1.10.1 h1:T0ujvqyCSqRopADpgPgiTT63DUQVSfojyME59Ei63pQ=
    github.com/gin-gonic/gin v1.10.1/go.mod h1:4PMNQiOhvDRa013RKVbsiNwoyezlm2rm0uX/T7kzp5Y=
    github.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=
    github.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=
    github.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=
    github.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=
    github.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=
    github.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=
    github.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=
    github.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=
    github.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=
    github.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=
    github.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=
    github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
    github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
    github.com/invopop/jsonschema v0.12.0 h1:6ovsNSuvn9wEQVOyc72aycBMVQFKz7cPdMJn10CvzRI=
    github.com/invopop/jsonschema v0.12.0/go.mod h1:ffZ5Km5SWWRAIN6wbDXItl95euhFz2uON45H2qjYt+0=
    github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
    github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
    github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
    github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
    github.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=
    github.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=
    github.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=
    github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
    github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
    github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
    github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
    github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
    github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
    github.com/metoro-io/mcp-golang v0.13.0 h1:54TFBJIW76VRB55CJovQQje9x4GnXg0BQQwGRtXrbCE=
    github.com/metoro-io/mcp-golang v0.13.0/go.mod h1:ifLP9ZzKpN1UqFWNTpAHOqSvNkMK6b7d1FSZ5Lu0lN0=
    github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
    github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
    github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
    github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
    github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
    github.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=
    github.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=
    github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
    github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
    github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
    github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
    github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
    github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
    github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
    github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
    github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
    github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
    github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
    github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
    github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
    github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
    github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
    github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
    github.com/tidwall/gjson v1.14.2/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
    github.com/tidwall/gjson v1.18.0 h1:FIDeeyB800efLX89e5a8Y0BNH+LOngJyGrIWxG2FKQY=
    github.com/tidwall/gjson v1.18.0/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
    github.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=
    github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
    github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
    github.com/tidwall/pretty v1.2.1 h1:qjsOFOWWQl+N3RsoF5/ssm1pHmJJwhjlSbZ51I6wMl4=
    github.com/tidwall/pretty v1.2.1/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
    github.com/tidwall/sjson v1.2.5 h1:kLy8mja+1c9jlljvWTlSazM7cKDRfJuR/bOJhcY5NcY=
    github.com/tidwall/sjson v1.2.5/go.mod h1:Fvgq9kS/6ociJEDnK0Fk1cpYF4FIW6ZF7LAe+6jwd28=
    github.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=
    github.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=
    github.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=
    github.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=
    github.com/wk8/go-ordered-map/v2 v2.1.8 h1:5h/BUHu93oj4gIdvHHHGsScSTMijfx5PeYkE/fJgbpc=
    github.com/wk8/go-ordered-map/v2 v2.1.8/go.mod h1:5nJHM5DyteebpVlHnWMV0rPz6Zp7+xBAnxjb1X5vnTw=
    golang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=
    golang.org/x/arch v0.8.0 h1:3wRIsP3pM4yUptoR96otTUOXI367OS0+c9eeRi9doIc=
    golang.org/x/arch v0.8.0/go.mod h1:FEVrYAQjsQXMVJ1nsMoVVXPZg6p2JE2mx8psSWTDQys=
    golang.org/x/crypto v0.23.0 h1:dIJU/v2J8Mdglj/8rJ6UUOM3Zc9zLZxVZwwxMooUSAI=
    golang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=
    golang.org/x/net v0.25.0 h1:d/OCCoBEUq33pjydKrGQhw7IlUPI2Oylr+8qLx49kac=
    golang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=
    golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
    golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
    golang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=
    golang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
    golang.org/x/text v0.15.0 h1:h1V/4gjBv8v9cjcR6+AR5+/cIYK5N/WAgiv4xlsEtAk=
    golang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
    golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
    golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
    google.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=
    google.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
    gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
    gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
    gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
    gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
    gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
    nullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=
    rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
